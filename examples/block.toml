[settings]
endianness = "little"
virtual_offset = 0x0
byte_swap = false
pad_to_end = false

[settings.crc]
polynomial = 0x04C11DB7
start = 0xFFFFFFFF
xor_out = 0xFFFFFFFF
ref_in = true
ref_out = true
area = "data"

[block.header]
start_address = 0x8B000
length = 0x1000
crc_location = "end"
padding = 0xC0

[block.data]
# Literal numeric value
some.struct.value = { value = 0x1234, type = "u32" }
# Single value from Excel by name (numeric)
some.struct.value2 = { name = "Value 2", type = "u32" }
# Fixed-size string literal (padded with padding byte)
some.struct.value3 = { value = "Value 3", type = "u8", size = 10 }

# Strings and scalars from Excel
device.info.name = { name = "DeviceName", type = "u8", size = 16 }
device.info.serial = { name = "SerialNumber", type = "u32" }
device.info.version.major = { name = "FWVersionMajor", type = "u16" }
device.info.version.minor = { name = "FWVersionMinor", type = "u16" }
device.info.version.patch = { name = "FWVersionPatch", type = "u16" }

# Network and credentials
wifi.ssid = { name = "WiFiSSID", type = "u8", size = 32 }
wifi.key = { name = "WiFiKey", type = "u8", size = 64 }
net.ip = { value = [192, 168, 1, 100], type = "u8", size = 4 }

# Arrays from Excel
# Use 'size' (lowercase) to allow padding if Excel data is shorter than specified
calibration.coefficients = { name = "Coefficients1D", type = "f32", size = 8 }
calibration.matrix = { name = "CalibrationMatrix", type = "i16", size = [3, 3] }
# Use 'SIZE' (uppercase) to enforce exact length - error if Excel data is shorter
# calibration.strict_coefficients = { name = "SomeArray", type = "f32", SIZE = 8 }

# Another fixed-size string literal
message = { value = "Hello, world!", type = "u8", size = 16 }
# Magic constant
magic = { value = 0xDEADBEEF, type = "u32" }

# Deeper nesting example (inline scalar and 1D array)
nested.complex.level1.level2.level3.scalar16 = { value = 0x42, type = "u16" }
nested.complex.level1.level2.level3.array1d = { value = [
    1,
    2,
    3,
    4,
], type = "i16", size = 4 }

# Arrays-of-structs as 2D arrays
# AStruct { f32 A; f32 B; } AStructs[10]
structs.astruct_array = { name = "AStructs", type = "f32", size = [10, 2] }

[block2.header]
start_address = 0x8C000
length = 0x1000
crc_location = 0x8CFF0

[block2.data]
# 2D array of u16 read from Excel sheet referenced by the Main sheet value
another.struct.value = { name = "Array", type = "u16", size = [10, 2] }
# 1D numeric array literal
another.struct.arr = { value = [2, 2], type = "u16", size = 2 }
# String from Excel (or sheet name for byte array)
another.struct.description = { name = "Block2Description", type = "u8", size = 32 }

[block3.header]
start_address = 0x8D000
length = 0x1000
crc_location = 0x8DFF0

[block3.data]
# Demonstrate wider and signed types
counters.boot_count = { name = "BootCount", type = "u64" }
limits.temperature_min = { name = "TemperatureMin", type = "i16" }
limits.temperature_max = { name = "TemperatureMax", type = "i16" }
thresholds.voltage = { name = "VoltageThresholds", type = "f32", size = 4 }
# Large notice string or bytes from Excel
dlegal.notice = { name = "LegalNotice", type = "u8", size = 128 }
